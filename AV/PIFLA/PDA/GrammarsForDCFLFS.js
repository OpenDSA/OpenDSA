// Title: Grammars for Deterministic CFL
// Author: Mostafa Mohammed; Cliff Shaffer
// Institution: Virginia Tech
// Features: Demonstration
// Keyword: Context-Free Languages
// Natural Language: en
// Programming Language: N/A
/* Description: Programmed Instruction Frameset discussing grammars for deterministic context free languages. */

$(document).ready(function() {
  "use strict";
  var av_name = "GrammarsForDCFLFS";
  var av = new JSAV(av_name);
  var Frames = PIFRAMES.init(av_name);

  //Frame 1
  av.umsg("Now we know that:<br/><ul><li>All CFLs can be generated by a CFG, and recognized by a NPDA.<li>Not all CFLs can be recognized using a DPDA.<li>So some CFG are associated with only non-deterministic PDAs.</ul>Nondeterminism gives us something more in terms of capability.");
  av.displayInit();

  // Frame 2
  av.umsg("Why do we care? Because we want to parse efficiently. This means, we want to quickly determine if a given string can be generated from a given grammar. Determinism seems to be a fundamental requirement if we hope to do this efficiently.");
  av.step();

  // Frame 3
  av.umsg("Think of a PDA as a parsing device. No backtracking requires that we can make a decision at every step on what to do next. This is the same as knowing which grammar production comes next.<br/><br/>Clearly this is linear time when the grammar has been simplified (no unit productions), because every derivation step consumes an input character. Well... except for $\\lambda$ productions. But we will see soon that these are not really a problem for linear-time processing.");
  av.step();

  // Frame 4
  av.umsg("Parsing algorithm: <b>Top-down Parsing with Lookahead</b><br/>Start with the start symbol $S$. Scan left-to-right through the string. At each step, we want only to follow one rule when we look at the current character. Perhaps we don’t see a production for the current character, but instead pop something off the stack (λ production). This is why λ productions are still linear, if we don’t put too much on the stack when we process a character.");
  av.step();

  // Frame 5
  av.umsg("$\\textbf{S-grammars}$<br/>Recall that an S-grammar has all productions of the form: $A \\rightarrow ax$ where $A \\in V$, $a\\in T$, and $x\\in V^*$, and any pair $(A,a)$ can occur in at most one rule.<br/><br/>Obviously this can be parsed efficiently. But, S-grammars are more restrictive than we want. Lots of useful language constructs cannot be defined using an s-grammar. We want to generalize as much as we can to capture a broader subset of CFLs.");
  av.step();

  // Frame 6
  av.umsg(Frames.addQuestion("notsgrammar"));
  av.step();

  // Frame 7
  av.umsg(Frames.addQuestion("ab"));
  av.step();

  // Frame 8
  av.umsg(Frames.addQuestion("sure"));
  av.step();

  // Frame 9
  av.umsg(Frames.addQuestion("aa"));
  av.step();

  // Frame 10
  av.umsg(Frames.addQuestion("aasure"));
  av.step();

  // Frame 11
  av.umsg("<b>LL(k) Grammars:</b><br/>LL means “left-to-right” and that a “left-most derivation” is constructed. $k$ means that we can decide which production to fire next by looking at at most the next $k$ symbols. Every S-grammar is LL, but so are more grammars.<br/><br/>Consider the grammar $S \\rightarrow SS \\mid aSb \\mid ab$. This is a useful grammar! It captures nested parentheses. And it is a CFG. Unfortunately, it is not an $LL(k)$ grammar for any constant $k$.<br/><br/>Just because this <b>grammar</b> is not $LL(k)$ does not mean that the <b>language</b> might not be deterministic. Understanding why this was not $LL(k)$ should help you to see how to fix the grammar. The problem is that we cannot know whether to fire rule $S \\rightarrow SS$ until we complete the first $S$. But there is no way to know how many symbols are required to recognize this.");
  av.step();

  // Frame 12
  av.umsg(Frames.addQuestion("abab"));
  av.step();

  // Frame 13
  av.umsg(Frames.addQuestion("getb"));
  av.step();

  // Frame 14
  av.umsg(Frames.addQuestion("DCFL"));
  av.step();

  // Frame 15
  av.umsg("Congratulations! Frameset completed.");
  av.recorded();
});
