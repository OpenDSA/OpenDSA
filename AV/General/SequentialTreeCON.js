/*global ODSA */
"use strict";
// Sequential Tree serialization visualization slideshow

// Title: Binary Tree Serialization Slideshow
// Author: Kevin Ellis
// Institution: Virginia Tech
// Features: Algorithm Visualization
// Keyword: Serialization; Binary Tree
// Natural Language: en
// Programming Language: N/A
/* Description: Slideshow how to reconstruct a binary tree from a serialized representation of its node values. */

$(document).ready(function () {
  var av_name = "SequentialTreeCON";
  var av = new JSAV(av_name);
  var temp1;
  var arr = av.ds.array(['A', 'B', '/', 'D', '/', '/', 'C', 'E', 'G', '/',
                         '/', '/', 'F', 'H', '/', '/', 'I', '/', '/']);
  var bt = av.ds.binarytree({visible: true, nodegap: 35});
  bt.root('A');
  var a = bt.root();
  a.left('B');
  var b = a.left();
  var d = a.left().right('D');
  var c = a.right('C');
  var e = a.right().left('E');
  var g = a.right().left().left('G');
  var f = a.right().right('F');
  var h = a.right().right().left('H');
  var i = a.right().right().right('I');

  a.hide(); // Hide all nodes in the tree

  //Slide 1
  av.umsg("The sequential representation in the array was generated by a simple preorder traversal. Now we will see how to reconstruct the original tree.");
  av.displayInit();

  // Slide 2
  av.umsg("We begin with the first node in the string 'A' which will be the root node");
  arr.highlight(0);
  a.show({recursive: false});
  bt.layout();
  var ptr = av.pointer("rt", bt.root(), {anchor: "center top", top: -10});
  av.step();

  //Slide 3
  av.umsg("The next character in the serialized string represents A's left child");
  arr.highlight(1);
  arr.unhighlight(0);
  av.step();

  //Slide 4
  av.umsg("We insert B as the left child of A");
  a.addClass("processing");
  b.show({recursive: false});
  bt.layout();
  ptr.target(b);
  av.step();

  //Slide 5
  av.umsg("The next character in the serialized string says B has no left child ('/') ");
  arr.highlight(2);
  arr.unhighlight(1);
  av.step();

  //Slide 6
  av.umsg("The next token 'D' is the right child of 'B' ");
  b.addClass("processing");
  d.show();
  bt.layout();
  ptr.target(d);
  arr.highlight(3);
  arr.unhighlight(2);
  //point to D
  av.step();

  //Slide 7
  arr.highlight(4);
  arr.highlight(5);
  arr.unhighlight(3);
  av.umsg("The two slashes imply D has no children and is a leaf node");
  av.step();

  //Slide 8
  av.umsg("We pop back up to the parent of D");
  //point to B
  ptr.target(b);
  b.removeClass("processing");
  av.step();

  //Slide 9
  av.umsg("Since we have already processed both of B's children, we continue popping up to the root.");
  //point to A
  ptr.target(a);
  a.removeClass("processing");
  av.step();

  //Slide 10
  av.umsg("The next character in the string represents A's right child 'C' ");
  c.show({recursive: false});
  bt.layout();
  ptr.target(c);
  a.addClass("processing");
  arr.highlight(6);
  arr.unhighlight(4);
  arr.unhighlight(5);
  //point to C
  av.step();

  //Slide 11
  av.umsg("'E' must be C's left child");
  e.show({recursive: false});
  bt.layout();
  ptr.target(e);
  c.addClass("processing");
  arr.highlight(7);
  arr.unhighlight(6);
  //point to E
  av.step();

  //Slide 12
  av.umsg("The next character 'G' represents E's left child");
  g.show({recursive: false});
  bt.layout();
  ptr.target(g);
  e.addClass("processing");
  arr.highlight(8);
  arr.unhighlight(7);
  //point to G
  av.step();

  //Slide 13
  av.umsg("Double slashes implies G has no children");
  arr.highlight(9);
  arr.highlight(10);
  arr.unhighlight(8);
  av.step();

  //Slide 14
  av.umsg("Pop back up to G's parent ('E') ");
  ptr.target(e);
  e.removeClass("processing");
  //point to E
  av.step();

  //Slide 15
  av.umsg("The next character in the serialized string ('/') represents E's right child");
  arr.highlight(11);
  arr.unhighlight(9);
  arr.unhighlight(10);
  av.step();

  //Slide 16
  av.umsg("It is a slash, so no right child for E");
  av.step();

  //Slide 17
  av.umsg("We pop back up to E's parent ('C') ");
  //point to C
  ptr.target(c);
  c.removeClass("processing");
  av.step();

  //Slide 18
  av.umsg("F represents C's right child");
  f.show({recursive: false});
  bt.layout();
  ptr.target(f);
  c.addClass("processing");
  arr.highlight(12);
  arr.unhighlight(11);
  //point to F
  av.step();

  //Slide 19
  av.umsg("H represents F's left child");
  h.show({recursive: false});
  bt.layout();
  ptr.target(h);
  f.addClass("processing");
  arr.highlight(13);
  arr.unhighlight(12);
  //point to H
  av.step();

  //Slide 20
  av.umsg("Double slash implies H is a leaf node with no children. Pop back up to F");
  ptr.target(f);
  f.removeClass("processing");
  arr.highlight(14);
  arr.highlight(15);
  arr.unhighlight(13);
  av.step();

  //Slide 21
  av.umsg("I must be the right child of F");
  i.show({recursive: false});
  bt.layout();
  //point to I
  ptr.target(i);
  f.addClass("processing");
  arr.highlight(16);
  arr.unhighlight(14);
  arr.unhighlight(15);
  av.step();

  //Slide 22
  av.umsg("Double slashes implies I is a leaf node with no children");
  arr.highlight(17);
  arr.highlight(18);
  arr.unhighlight(16);
  av.step();

  //Slide 23
  av.umsg("Now we have reached the end of the sequential representation, and the tree has been reconstructed.");
  a.removeClass("processing");
  c.removeClass("processing");
  f.removeClass("processing");
  av.recorded();

});
