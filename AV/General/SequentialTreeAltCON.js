/*global ODSA */
"use strict";
// Sequential Tree alternative serialization visualization slideshow

// Title: Binary Tree Serialization Slideshow: Internal Node Mark Bits
// Author: Kevin Ellis
// Institution: Virginia Tech
// Features: Algorithm Visualization
// Keyword: Serialization; Binary Tree
// Natural Language: en
// Programming Language: N/A
/* Description: Slideshow how to reconstruct a binary tree from a serialized representation of its node values. Alternative representation using mark bits to distinguish internal from leaf nodes. */

$(document).ready(function () {
  var av_name = "SequentialTreeAltCON";
  var av = new JSAV(av_name);
  var temp1;
  var arr = av.ds.array(["A'", "B'", "/", "D", "C'", "E'", "G", "/",
                         "F'", "H", "I"]);
  var bt = av.ds.binarytree({visible: true, nodegap: 35});
  bt.root('A');
  var a = bt.root();
  a.left('B');
  var b = a.left();
  var d = a.left().right('D');
  var c = a.right('C');
  var e = a.right().left('E');
  var g = a.right().left().left('G');
  var f = a.right().right('F');
  var h = a.right().right().left('H');
  var i = a.right().right().right('I');

  a.hide();

  // Slide 1
  av.umsg("The sequential representation in the array was generated by a simple preorder traversal. Now we will see how to reconstruct the original tree.");
  av.displayInit();


  // Slide 2
  av.umsg("The first character A' means A is an internal node, and is the root node");
  a.show({recursive: false});
  bt.layout();
  var ptr = av.pointer("rt", bt.root(), {anchor: "center top", top: -10});
  arr.highlight(0);
  av.step();

  // Slide 3
  av.umsg("B is A's left child");
  arr.highlight(1);
  arr.unhighlight(0);
  av.step();

  // Slide 4
  av.umsg("We insert B as the left child of A");
  b.show({recursive: false});
  bt.layout();
  a.addClass("processing");
  ptr.target(b);
  av.step();

  // Slide 5
  av.umsg("We know that B is an internal node (because of the ' mark).");
  av.step();

  // Slide 6
  av.umsg("The '/' implies the left child is null (B does not have a left child)");
  b.left('/').show();
  bt.layout();
  arr.highlight(2);
  arr.unhighlight(1);
  av.step();

  // Slide 7
  av.umsg("The next token 'D' is the right child of 'B' ");
  d.show();
  bt.layout();
  //point to D
  ptr.target(d);
  b.addClass("processing");
  arr.highlight(3);
  arr.unhighlight(2);
  av.step();

  // Slide 8
  av.umsg("Since D was a leaf node, we know to pop back up to the parent of D");
  //point to B
  ptr.target(b);
  b.removeClass("processing");
  av.step();

  // Slide 9
  av.umsg("Since we have already processed both of B's children, we continue popping up to the root.");
  //point to A
  ptr.target(a);
  a.removeClass("processing");
  av.step();

  // Slide 10
  av.umsg("The next character in the string represents A's right child C' ");
  c.show({recursive: false});
  bt.layout();
  a.addClass("processing");
  arr.highlight(4);
  arr.unhighlight(3);
  ptr.target(c);
  //point to C
  av.step();

  // Slide 11
  av.umsg("'E' must be C's left child");
  e.show({recursive: false});
  bt.layout();
  arr.highlight(5);
  arr.unhighlight(4);
  //point to E
  ptr.target(e);
  c.addClass("processing");
  av.step();

  // Slide 12
  av.umsg("The next character 'G' represents E's left child");
  g.show({recursive: false});
  bt.layout();
  arr.highlight(6);
  arr.unhighlight(5);
  //point to G
  ptr.target(g);
  e.addClass("processing");
  av.step();

  // Slide 13
  av.umsg("G is a leaf node so we pop back to E");
  //point to E
  ptr.target(e);
  e.removeClass("processing");
  av.step();

  // Slide 14
  av.umsg("The next character in the serialized string ('/') represents E's right child (null)");
  e.right('/').show();
  arr.highlight(7);
  arr.unhighlight(6);
  bt.layout();
  av.step();

  // Slide 15
  av.umsg("We pop back up to E's parent ('C') ");
  //point to C
  ptr.target(c);
  c.removeClass("processing");
  av.step();

  // Slide 16
  av.umsg("F represents C's right child");
  f.show({recursive: false});
  bt.layout();
  arr.highlight(8);
  arr.unhighlight(7);
  //point to F
  ptr.target(f);
  c.addClass("processing");
  av.step();

  // Slide 17
  av.umsg("H represents F's left child");
  h.show({recursive: false});
  bt.layout();
  arr.highlight(9);
  arr.unhighlight(8);
  //point to H
  ptr.target(h);
  f.addClass("processing");
  av.step();

  // Slide 18
  av.umsg("H is a leaf node, so pop back up to F");
  ptr.target(f);
  f.removeClass("processing");
  av.step();

  // Slide 19
  av.umsg("I must be the right child of F");
  i.show({recursive: false});
  bt.layout();
  //point to I
  ptr.target(i);
  arr.highlight(10);
  arr.unhighlight(9);
  f.addClass("processing");
  av.step();

  // Slide 20
  av.umsg("I is a leaf node, so we have processed the entire string");
  a.removeClass("processing");
  c.removeClass("processing");
  f.removeClass("processing");
  av.recorded();

});
